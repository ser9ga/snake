{"version":3,"sources":["Square/index.js","Screen/index.js","GameControl/index.js","App.js","index.js","Square/Square.module.css","App.module.css","Screen/Screen.module.css"],"names":["Square","isFilled","className","styles","squareWrapper","square","filledSquare","innerSquare","filledInnerSquare","memo","Screen","screen","fieldSize","screenFrame","Array","y","map","row","rowIdY","rowLine","x","rowItem","rowIdX","currentSquareIndex","GameControl","dispatchSnakeState","useEffect","document","addEventListener","e","type","payload","removeEventListener","App","useMemo","initSnakeBody","isTarget","generateInitField","flatMap","_","j","i","initFieldChanges","reduce","acc","el","concat","prepareNewScreenState","screenState","changes","newScreenState","forEach","change","getSnakeParams","state","copiedState","filteredBodyState","body","cutTail","shift","direction","currentDirection","ax","nextDirection","cd","currenHead","length","getNextBodyPixel","prev","dir","newHead","getNextTarget","occupied","copiedScreen","splice","unfilledScreenPixels","filter","pix","Math","floor","random","initSnakeState","isGameRunning","isMatchIsOn","isGameOver","useReducer","action","nextHeadPlace","newSnakeBodyState","idx","newDirection","newTarget","preventDefault","ArrowLeft","ArrowRight","ArrowUp","ArrowDown","KeyA","KeyD","KeyW","KeyS","code","Error","snakeState","intervalRef","useRef","startInterval","interval","current","setInterval","stopInterval","clearInterval","buttonPanel","button","onClick","flag","obj","ReactDOM","render","StrictMode","getElementById","module","exports"],"mappings":"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","file":"static/js/main.d2594307.chunk.js","sourcesContent":["import { memo } from \"react\";\nimport styles from './Square.module.css';\n\nconst Square = ({ isFilled }) => {\n    return (\n        <div className={`${styles.squareWrapper}`}>\n            <div className={`${styles.square} ${isFilled && styles.filledSquare}`} >\n                <div className={`${styles.innerSquare} ${isFilled && styles.filledInnerSquare}`} />\n            </div>\n        </div>\n    )\n};\n\nexport default memo(Square);\n","import { memo } from \"react\";\nimport Square from \"../Square\";\nimport styles from './Screen.module.css';\n\nconst Screen = ({ screen, fieldSize }) => {\n    return (\n        <div className={styles.screen}>\n            <div className={styles.screenFrame}>\n                {[...Array(fieldSize.y)].map((row, rowIdY) => (\n                    <div key={rowIdY} className={styles.rowLine}>\n                        {\n                            [...Array(fieldSize.x)].map((rowItem, rowIdX) => {\n                                const currentSquareIndex = fieldSize.x * rowIdY + rowIdX;\n                                return (\n                                    <Square key={`${rowIdX}_${rowIdY}`} isFilled={screen[currentSquareIndex].isFilled} />\n                                )\n                            })\n                        }\n                    </div>\n                ))\n                }\n            </div>\n        </div>\n    );\n}\n\nexport default memo(Screen);\n","import React, { useEffect } from 'react';\n\nconst GameControl = ({ dispatchSnakeState }) => {\n    useEffect(() => {\n        document.addEventListener('keydown', e => dispatchSnakeState({ type: 'keyPressHandler', payload: e }));\n\n        return () => {\n            document.removeEventListener('keydown', e => dispatchSnakeState({ type: 'keyPressHandler', payload: e }));\n        };\n    }, []);\n\n    return <div/>;\n};\n\nexport default GameControl;\n","import styles from './App.module.css';\nimport Screen from \"./Screen\";\nimport { useRef, useReducer, useEffect, useMemo} from \"react\";\nimport GameControl from \"./GameControl\";\n\nfunction App() {\n    const fieldSize = useMemo(() => ({ x: 20, y: 20}), []);\n\n    const initSnakeBody = [\n        {\n            x: 4,\n            y: 5,\n            isFilled: false,\n            isTarget: false\n        },\n        {\n            x: 5,\n            y: 5,\n            isFilled: true,\n            isTarget: false\n        },\n        {\n            x: 6,\n            y: 5,\n            isFilled: true,\n            isTarget: false\n        },\n        {\n            x: 7,\n            y: 5,\n            isFilled: true,\n            isTarget: false\n        }\n    ];\n\n    const generateInitField = useMemo(() => {\n        return [...Array(fieldSize.y)].flatMap((_, j) => [...Array(fieldSize.x)].map((_, i) =>\n            ({\n                x: i,\n                y: j,\n                isFilled: false,\n                isTarget: false\n            })))\n    }, [fieldSize]);\n\n    const initFieldChanges = useMemo(() => {\n        return generateInitField.reduce((acc, el) => {\n            if (el.x === 0 || el.x === fieldSize.x - 1 || el.y === 0 || el.y === fieldSize.y - 1) {\n                return acc.concat({ ...el, isFilled: true });\n            }\n\n            return acc;\n        }, [])\n    }, [fieldSize]);\n\n    const prepareNewScreenState = (screenState, changes) => {\n        let newScreenState = [...screenState];\n        changes.forEach(change => newScreenState[fieldSize.x * change.y + change.x] = change);\n\n        return newScreenState;\n    };\n\n    const getSnakeParams = state => {\n        let copiedState = {...state};\n        const filteredBodyState = copiedState.body\n        const cutTail = !filteredBodyState[0]['isFilled'] ? filteredBodyState.shift() : {};\n        filteredBodyState[0]['isFilled'] = true;\n        const direction = copiedState.currentDirection.ax === copiedState.nextDirection.ax ? 'currentDirection' : 'nextDirection';\n        const cd = copiedState[direction].ax === 'horizontal' ? 'x' : 'y';\n        const currenHead = {...filteredBodyState[filteredBodyState.length - 1]};\n        const getNextBodyPixel = prev => ({\n            ...prev,\n            [cd]: state[direction].dir === 'forward' ? prev[cd] + 1 : prev[cd] - 1,\n            isTarget: false\n        })\n        const newHead = getNextBodyPixel(currenHead);\n\n        return {\n            filteredBodyState,\n            direction,\n            currenHead,\n            cutTail,\n            getNextBodyPixel,\n            newHead\n        }\n    }\n\n    const getNextTarget = (screen, occupied) => {\n        let copiedScreen = [...screen];\n        occupied.forEach(change => {\n            copiedScreen.splice([fieldSize.x * change.y + change.x], 1);\n        });\n\n        const unfilledScreenPixels = copiedScreen.filter(pix => !pix.isFilled)\n\n        return {\n            ...unfilledScreenPixels[Math.floor(Math.random() * unfilledScreenPixels.length)],\n            isFilled: true,\n            isTarget: true,\n        };\n    }\n\n    const snakeStateReducer = (state, action) => {\n        if (action.type === 'setSnakeState'){\n            return { ...state, ...action.payload };\n        }\n\n        if (action.type === 'prepareAndExecNewTurn') {\n            const {\n                filteredBodyState,\n                direction,\n                cutTail,\n                newHead\n            } = getSnakeParams(state);\n\n            const nextHeadPlace = {...state.screen[fieldSize.x * newHead.y + newHead.x]};\n\n            if (nextHeadPlace.isFilled && !nextHeadPlace.isTarget) {\n                return {\n                    ...state,\n                    isGameRunning: false,\n                    isMatchIsOn: false,\n                    isGameOver: true,\n                    currentDirection: { dir: 'forward', ax: 'horizontal' },\n                    nextDirection: { dir: 'forward', ax: 'horizontal' }\n                }\n            }\n\n            let newSnakeBodyState = [...filteredBodyState];\n\n            if (nextHeadPlace.isTarget) {\n                newSnakeBodyState.splice(1, 0, { ...newSnakeBodyState[0], isFilled: false });\n            }\n\n            newSnakeBodyState = newSnakeBodyState\n                .map((pix, idx) => idx === 0 ? { ...pix, isFilled: false} : pix)\n                .concat(newHead);\n\n            let newScreenState = prepareNewScreenState(state.screen, newSnakeBodyState);\n\n            if (nextHeadPlace.isTarget) {\n                newScreenState = prepareNewScreenState(newScreenState, [getNextTarget(newScreenState, [cutTail])]);\n            }\n\n            const newDirection = state[direction];\n\n            return {\n                ...state,\n                screen: newScreenState,\n                body: newSnakeBodyState,\n                currentDirection: newDirection\n            };\n        }\n\n        if (action.type === 'setTargetPixelOnStart') {\n            const { newHead } = getSnakeParams(state);\n            const newTarget = getNextTarget(\n               state.screen, [...initSnakeBody, newHead]\n            );\n            const newScreenState = prepareNewScreenState(state.screen, [newTarget]);\n\n            return { ...state, screen: newScreenState };\n        }\n\n        if (action.type ==='keyPressHandler') {\n            action.payload.preventDefault();\n            const direction = {\n                ArrowLeft: { dir: 'backward', ax: 'horizontal' },\n                ArrowRight: { dir: 'forward', ax: 'horizontal' },\n                ArrowUp: { dir: 'backward', ax: 'vertical' },\n                ArrowDown: { dir: 'forward', ax: 'vertical' },\n                KeyA: { dir: 'backward', ax: 'horizontal' },\n                KeyD: { dir: 'forward', ax: 'horizontal' },\n                KeyW: { dir: 'backward', ax: 'vertical' },\n                KeyS: { dir: 'forward', ax: 'vertical' }\n            }[action.payload.code];\n\n            if (!(state.nextDirection.dir ===  direction?.dir && state.nextDirection.ax ===  direction?.ax) &&\n                direction &&\n                state.isGameRunning) {\n                return { ...state, nextDirection: direction }\n            }\n\n            if (action.payload.code === 'Space') {\n                return ({\n                    ...state,\n                    isGameRunning: !state.isGameRunning,\n                    isMatchIsOn: true\n                })\n            }\n\n            if (action.payload.code === 'Backspace') {\n                return (initSnakeState);\n            }\n\n            return state;\n        }\n\n        return new Error();\n    }\n\n    const initSnakeState = {\n        isGameRunning: false,\n        isMatchIsOn: false,\n        isGameOver: false,\n        body: [...initSnakeBody],\n        screen: prepareNewScreenState(generateInitField, initFieldChanges),\n        currentDirection: { dir: 'forward', ax: 'horizontal' },\n        nextDirection: { dir: 'forward', ax: 'horizontal' }\n    };\n\n    const [snakeState, dispatchSnakeState] = useReducer(snakeStateReducer, initSnakeState);\n\n    let intervalRef = useRef();\n\n    const startInterval = (interval = 500) => {\n        if(!intervalRef.current) {\n            intervalRef.current = setInterval(() => dispatchSnakeState({ type: 'prepareAndExecNewTurn' }), interval);\n        }\n    };\n\n    const stopInterval = () => {\n        if (intervalRef.current) {\n            clearInterval(intervalRef.current);\n            intervalRef.current = null;\n        }\n    };\n\n    useEffect(() => {\n        if(snakeState.isGameRunning) {\n            startInterval();\n        }\n\n        if (!snakeState.isGameRunning) {\n            stopInterval();\n        }\n    }, [snakeState.isGameRunning]);\n\n    const startOrPauseGame = () => {\n        const {isMatchIsOn, isGameRunning, isGameOver, body, screen} = snakeState;\n        dispatchSnakeState({\n            type: 'setSnakeState',\n            payload: {\n                isGameOver: false,\n                isMatchIsOn: true,\n                isGameRunning: !isGameRunning,\n                screen: !isMatchIsOn ? prepareNewScreenState(generateInitField, [...initFieldChanges, ...initSnakeBody]) : screen,\n                body: isGameOver ? [...initSnakeState.body] : body,\n            }\n        });\n\n        !isMatchIsOn && dispatchSnakeState({\n            type: 'setTargetPixelOnStart'\n        })\n    };\n\n    const resetGame = () => {\n        const { isGameRunning, isGameOver } = snakeState;\n        const flag = isGameRunning || isGameOver;\n        const obj = flag ?\n            {\n                isGameRunning: true,\n                isMatchIsOn: true,\n                screen: prepareNewScreenState(generateInitField, [...initFieldChanges, ...initSnakeBody])\n            } : {}\n\n        flag && stopInterval();\n\n        dispatchSnakeState({\n            type: 'setSnakeState',\n            payload: {\n                ...initSnakeState,\n                ...obj\n            }\n        });\n\n        (isGameRunning || isGameOver) && dispatchSnakeState({\n            type: 'setTargetPixelOnStart'\n        });\n\n        flag && startInterval();\n    };\n\n    return (\n        <div className={styles.App}>\n            <Screen screen={snakeState.screen} fieldSize={fieldSize} />\n            <div className={styles.buttonPanel}>\n                <button className={styles.button} onClick={startOrPauseGame}>{snakeState.isGameRunning ? 'Pause' : 'Start'}</button>\n                <button className={styles.button} onClick={resetGame}>Reset</button>\n            </div>\n            <GameControl dispatchSnakeState={dispatchSnakeState} />\n        </div>\n    );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport './styles.css'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"squareWrapper\":\"Square_squareWrapper__1-5jq\",\"square\":\"Square_square__5MeBN\",\"filledSquare\":\"Square_filledSquare__3nVrd\",\"innerSquare\":\"Square_innerSquare__1V41H\",\"filledInnerSquare\":\"Square_filledInnerSquare__3sDlX\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"App\":\"App_App__16ZpL\",\"buttonPanel\":\"App_buttonPanel__24-jo\",\"button\":\"App_button__13pio\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"App\":\"Screen_App__28xjI\",\"screen\":\"Screen_screen__Q0lyG\",\"screenFrame\":\"Screen_screenFrame__BXMp8\",\"rowLine\":\"Screen_rowLine__1HFM3\"};"],"sourceRoot":""}