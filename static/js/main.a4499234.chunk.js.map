{"version":3,"sources":["Screen/Screen.module.css","Square/index.js","Screen/index.js","GameControl/index.js","Hooks/useLogic.js","App.js","index.js","Square/Square.module.css","App.module.css"],"names":["module","exports","Square","isFilled","className","styles","squareWrapper","square","filledSquare","innerSquare","filledInnerSquare","memo","Screen","screen","fieldSize","screenFrame","Array","y","map","row","rowIdY","rowLine","x","rowItem","rowIdX","currentSquareIndex","GameControl","keyPressHandler","handler","event","useEffect","document","addEventListener","removeEventListener","useLogic","intervalRef","useRef","useMemo","initSnakeBody","_","index","isTarget","generateInitField","flatMap","j","i","initFieldChanges","reduce","acc","el","concat","prepareNewScreenState","screenState","changes","newScreenState","forEach","change","initSnakeState","restartFlag","isGameRunning","isMatchIsOn","isGameOver","body","currentDirection","dir","ax","nextDirection","getSnakeParams","state","copiedState","filteredBodyState","cutTail","shift","direction","cd","currenHead","length","getNextBodyPixel","prev","newHead","getNextTarget","occupied","copiedScreen","splice","unfilledScreenPixels","filter","pix","Math","floor","random","setTargetPixel","newTarget","useReducer","action","type","nextHeadPlace","newSnakeBodyState","idx","newDirection","payload","preventDefault","ArrowLeft","ArrowRight","ArrowUp","ArrowDown","KeyA","KeyD","KeyW","KeyS","code","stateWithoutTarget","setParams","fillScreen","Error","snakeState","dispatchSnakeState","resetGame","a","startOrPauseGame","current","setInterval","clearInterval","App","buttonPanel","button","onClick","ReactDOM","render","StrictMode","getElementById"],"mappings":"kFACAA,EAAOC,QAAU,CAAC,IAAM,oBAAoB,OAAS,uBAAuB,YAAc,4BAA4B,QAAU,0B,+ICE1HC,EAAS,SAAC,GAAkB,IAAhBC,EAAe,EAAfA,SACd,OACI,qBAAKC,UAAS,UAAKC,IAAOC,eAA1B,SACI,qBAAKF,UAAS,UAAKC,IAAOE,OAAZ,YAAsBJ,GAAYE,IAAOG,cAAvD,SACI,qBAAKJ,UAAS,UAAKC,IAAOI,YAAZ,YAA2BN,GAAYE,IAAOK,0BAM7DC,iBAAKT,G,iBCTdU,EAAS,SAAC,GAA2B,IAAzBC,EAAwB,EAAxBA,OAAQC,EAAgB,EAAhBA,UACtB,OACI,qBAAKV,UAAWC,IAAOQ,OAAvB,SACI,qBAAKT,UAAWC,IAAOU,YAAvB,SACK,YAAIC,MAAMF,EAAUG,IAAIC,KAAI,SAACC,EAAKC,GAAN,OACzB,qBAAkBhB,UAAWC,IAAOgB,QAApC,SAEQ,YAAIL,MAAMF,EAAUQ,IAAIJ,KAAI,SAACK,EAASC,GAClC,IAAMC,EAAqBX,EAAUQ,EAAIF,EAASI,EAClD,OACI,cAAC,EAAD,CAAoCrB,SAAUU,EAAOY,GAAoBtB,UAAzE,UAAgBqB,EAAhB,YAA0BJ,QALhCA,WAiBfT,iBAAKC,GCVLc,EAdK,SAAC,GAAyB,IAAvBC,EAAsB,EAAtBA,gBACbC,EAAU,SAAAC,GAAK,OAAIF,EAAgBE,IAUzC,OARAC,qBAAU,WAGN,OAFAC,SAASC,iBAAiB,UAAWJ,GAE9B,WACHG,SAASE,oBAAoB,UAAWL,MAE7C,IAEI,yB,8CCqSIM,EA3SE,WACb,IAAIC,EAAcC,mBAEZtB,EAAYuB,mBAAQ,iBAAO,CAAEf,EAAG,GAAIL,EAAG,MAAM,IAE7CqB,EAAgB,YAAItB,MAAM,IAC3BE,KAAI,SAACqB,EAAGC,GAAJ,MAAe,CAChBlB,EAAGkB,EAAQ,EACXvB,EAAG,EACHd,WAAYqC,EACZC,UAAU,MAGZC,EAAoBL,mBAAQ,WAC9B,OAAO,YAAIrB,MAAMF,EAAUG,IAAI0B,SAAQ,SAACJ,EAAGK,GAAJ,OAAU,YAAI5B,MAAMF,EAAUQ,IAAIJ,KAAI,SAACqB,EAAGM,GAAJ,MACxE,CACGvB,EAAGuB,EACH5B,EAAG2B,EACHzC,UAAU,EACVsC,UAAU,WAEnB,CAAC3B,IAEEgC,EAAmBT,mBAAQ,WAC7B,OAAOK,EAAkBK,QAAO,SAACC,EAAKC,GAClC,OAAa,IAATA,EAAG3B,GAAW2B,EAAG3B,IAAMR,EAAUQ,EAAI,GAAc,IAAT2B,EAAGhC,GAAWgC,EAAGhC,IAAMH,EAAUG,EAAI,EACxE+B,EAAIE,OAAJ,2BAAgBD,GAAhB,IAAoB9C,UAAU,KAGlC6C,IACR,MACJ,CAAClC,IAGEqC,EAAwB,SAACC,EAAaC,GACxC,IAAIC,EAAc,YAAOF,GAGzB,OAFAC,EAAQE,SAAQ,SAAAC,GAAM,OAAIF,EAAexC,EAAUQ,EAAIkC,EAAOvC,EAAIuC,EAAOlC,GAAKkC,KAEvEF,GAGLG,EAAiB,CACnBC,aAAa,EACbC,eAAe,EACfC,aAAa,EACbC,YAAY,EACZC,KAAK,YAAKxB,GACVzB,OAAQsC,EAAsBT,EAAmBI,GACjDiB,iBAAkB,CAAEC,IAAK,UAAWC,GAAI,cACxCC,cAAe,CAAEF,IAAK,UAAWC,GAAI,eAGnCE,EAAiB,SAAAC,GACnB,IAAIC,EAAW,eAAOD,GAChBE,EAAoBD,EAAYP,KAChCS,EAAWD,EAAkB,GAAlB,SAA+D,GAA5BA,EAAkBE,QACtEF,EAAkB,GAAlB,UAAmC,EACnC,IAAMG,EAAYJ,EAAYN,iBAAiBE,KAAOI,EAAYH,cAAcD,GAAK,mBAAqB,gBACpGS,EAAmC,eAA9BL,EAAYI,GAAWR,GAAsB,IAAM,IACxDU,EAAU,eAAOL,EAAkBA,EAAkBM,OAAS,IAC9DC,EAAmB,SAAAC,GAAI,wCACtBA,GADsB,uBAExBJ,EAA8B,YAAzBN,EAAMK,GAAWT,IAAoBc,EAAKJ,GAAM,EAAII,EAAKJ,GAAM,GAF5C,0BAGf,GAHe,KAKvBK,EAAUF,EAAiBF,GAEjC,MAAO,CACHL,oBACAG,YACAE,aACAJ,UACAM,mBACAE,YAIFC,EAAgB,SAACnE,EAAQoE,GAC3B,IAAIC,EAAY,YAAOrE,GACvBoE,EAAS1B,SAAQ,SAAAC,GACb0B,EAAaC,OAAO,CAACrE,EAAUQ,EAAIkC,EAAOvC,EAAIuC,EAAOlC,GAAI,MAG7D,IAAM8D,EAAuBF,EAAaG,QAAO,SAAAC,GAAG,OAAKA,EAAInF,YAE7D,OAAO,2BACAiF,EAAqBG,KAAKC,MAAMD,KAAKE,SAAWL,EAAqBR,UAD5E,IAEIzE,UAAU,EACVsC,UAAU,KAIZiD,EAAiB,SAAAtB,GAAU,IACrBW,EAAYZ,EAAeC,GAA3BW,QACFY,EAAYX,EACdZ,EAAMvD,OADqB,sBACTyB,GADS,CACMyC,KAIrC,MAAO,CAAElE,OAFcsC,EAAsBiB,EAAMvD,OAAQ,CAAC8E,MAjG7C,EAgPsBC,sBA1If,SAACxB,EAAOyB,GAC9B,GAAoB,0BAAhBA,EAAOC,KAAkC,CAAC,IAAD,EAMrC3B,EAAeC,GAJfE,EAFqC,EAErCA,kBACAG,EAHqC,EAGrCA,UACAF,EAJqC,EAIrCA,QACAQ,EALqC,EAKrCA,QAGEgB,EAAa,eAAO3B,EAAMvD,OAAOC,EAAUQ,EAAIyD,EAAQ9D,EAAI8D,EAAQzD,IAEzE,GAAIyE,EAAc5F,WAAa4F,EAActD,SACzC,OAAO,2BACA2B,GADP,IAEIT,eAAe,EACfC,aAAa,EACbC,YAAY,EACZE,iBAAkB,CAAEC,IAAK,UAAWC,GAAI,cACxCC,cAAe,CAAEF,IAAK,UAAWC,GAAI,gBAI7C,IAAI+B,EAAiB,YAAO1B,GAExByB,EAActD,UACduD,EAAkBb,OAAO,EAAG,EAA5B,2BAAoCa,EAAkB,IAAtD,IAA0D7F,UAAU,KAGxE6F,EAAoBA,EACf9E,KAAI,SAACoE,EAAKW,GAAN,OAAsB,IAARA,EAAA,2BAAiBX,GAAjB,IAAsBnF,UAAU,IAASmF,KAC3DpC,OAAO6B,GAEZ,IAAIzB,EAAiBH,EAAsBiB,EAAMvD,OAAQmF,GAErDD,EAActD,WACda,EAAiBH,EAAsBG,EAAgB,CAAC0B,EAAc1B,EAAgB,CAACiB,OAG3F,IAAM2B,EAAe9B,EAAMK,GAE3B,OAAO,2BACAL,GADP,IAEIvD,OAAQyC,EACRQ,KAAMkC,EACNjC,iBAAkBmC,IAI1B,GAAmB,oBAAfL,EAAOC,KAA2B,CAClCD,EAAOM,QAAQC,iBACf,IAAM3B,EAAY,CACd4B,UAAW,CAAErC,IAAK,WAAYC,GAAI,cAClCqC,WAAY,CAAEtC,IAAK,UAAWC,GAAI,cAClCsC,QAAS,CAAEvC,IAAK,WAAYC,GAAI,YAChCuC,UAAW,CAAExC,IAAK,UAAWC,GAAI,YACjCwC,KAAM,CAAEzC,IAAK,WAAYC,GAAI,cAC7ByC,KAAM,CAAE1C,IAAK,UAAWC,GAAI,cAC5B0C,KAAM,CAAE3C,IAAK,WAAYC,GAAI,YAC7B2C,KAAM,CAAE5C,IAAK,UAAWC,GAAI,aAC9B4B,EAAOM,QAAQU,MAEjB,OAAMzC,EAAMF,cAAcF,OAApB,OAA6BS,QAA7B,IAA6BA,OAA7B,EAA6BA,EAAWT,MAAOI,EAAMF,cAAcD,MAApB,OAA4BQ,QAA5B,IAA4BA,OAA5B,EAA4BA,EAAWR,MACxFQ,GACAL,EAAMT,cACC,2BAAKS,GAAZ,IAAmBF,cAAeO,IAG/BL,EAGX,GAAoB,iBAAhByB,EAAOC,KAAyB,CAAC,IAE7BnC,EAKAS,EALAT,cACAC,EAIAQ,EAJAR,YACAC,EAGAO,EAHAP,WACAC,EAEAM,EAFAN,KACAjD,EACAuD,EADAvD,OAGEiG,EAAkB,2BACjB1C,GADiB,IAEpBP,YAAY,EACZD,aAAa,EACbD,eAAgBA,EAChB9C,OAAS+C,EAAkG/C,EAApFsC,EAAsBT,EAAD,sBAAwBI,GAAxB,YAA6CR,KACzFwB,KAAMD,EAAU,YAAOJ,EAAeK,MAAQA,IAGlD,OAAO,2BACAgD,IACElD,GAAe8B,EAAeoB,IAI3C,GAAoB,iBAAhBjB,EAAOC,KAAyB,CAAC,IACzBpC,EAAwDU,EAAxDV,YAAaC,EAA2CS,EAA3CT,cAAeC,EAA4BQ,EAA5BR,YAAaC,EAAeO,EAAfP,WAC3CkD,EAAY,CACdpD,gBAAgBC,IAAeC,IAAoBF,EACnDC,cAAcF,GAAcG,GAG1BmD,EAAatD,GAAeG,EAAa,CAC3ChD,OAAQsC,EAAsBT,EAAD,sBAAwBI,GAAxB,YAA6CR,MAC1E,GAEEwE,EAAkB,+DACjB1C,GACAX,GACAsD,GACAC,GAJiB,IAKpBtD,YAAaA,IAGjB,OAAO,2BACAoD,IACGpD,GAAeE,GAAgBC,IAAe6B,EAAeoB,IAI3E,MAAoB,iBAAhBjB,EAAOC,KACA,2BACA1B,GADP,IAEIV,YAAaU,EAAMT,eAAiBS,EAAMP,WAC1CF,eAAe,IAIH,kBAAhBkC,EAAOC,KACA,2BACA1B,GADP,IAEIV,aAAa,EACbC,cAAeS,EAAMV,cAItB,IAAIuD,QAGwDxD,GAhPpD,mBAgPZyD,EAhPY,KAgPAC,EAhPA,KAkPbC,EAAS,uCAAG,sBAAAC,EAAA,sEACRF,EAAmB,CACrBrB,KAAM,iBAFI,uBAKRqB,EAAmB,CACrBrB,KAAM,iBANI,uBASRqB,EAAmB,CACrBrB,KAAM,kBAVI,2CAAH,qDA+BTwB,EAAgB,uCAAG,sBAAAD,EAAA,sEACfF,EAAmB,CACrBrB,KAAM,iBAFW,2CAAH,qDAiBtB,OAXAhE,qBAAU,WACHoF,EAAWvD,gBACVxB,EAAYoF,QAAUC,aAAY,kBAAML,EAAmB,CAAErB,KAAM,4BAA4B,MAG9FoB,EAAWvD,gBACZ8D,cAActF,EAAYoF,SAC1BpF,EAAYoF,QAAU,QAE3B,CAACL,EAAWvD,gBAER,CACH7C,YACAoG,aACAI,mBACAF,YACAzF,gBAvCoB,SAAAE,GACpBA,EAAMuE,iBAENe,EAAmB,CACfrB,KAAM,kBACNK,QAAStE,IAGM,UAAfA,EAAMgF,MACNS,IAGe,cAAfzF,EAAMgF,MACNO,OC1PGM,EArBH,WAAO,IAAD,EAOVxF,IALApB,EAFU,EAEVA,UACAoG,EAHU,EAGVA,WACAI,EAJU,EAIVA,iBACAF,EALU,EAKVA,UACAzF,EANU,EAMVA,gBAGJ,OACI,sBAAKvB,UAAWC,IAAOqH,IAAvB,UACI,cAAC,EAAD,CAAQ7G,OAAQqG,EAAWrG,OAAQC,UAAWA,IAC9C,sBAAKV,UAAWC,IAAOsH,YAAvB,UACI,wBAAQvH,UAAWC,IAAOuH,OAAQC,QAASP,EAA3C,SAA8DJ,EAAWvD,eAAiBuD,EAAWxD,YAAc,QAAU,UAC7H,wBAAQtD,UAAWC,IAAOuH,OAAQC,QAAST,EAA3C,sBAEJ,cAAC,EAAD,CAAazF,gBAAiBA,Q,MChB1CmG,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFjG,SAASkG,eAAe,U,kBCR1BjI,EAAOC,QAAU,CAAC,cAAgB,8BAA8B,OAAS,uBAAuB,aAAe,6BAA6B,YAAc,4BAA4B,kBAAoB,oC,kBCA1MD,EAAOC,QAAU,CAAC,IAAM,iBAAiB,YAAc,yBAAyB,OAAS,uB","file":"static/js/main.a4499234.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"App\":\"Screen_App__28xjI\",\"screen\":\"Screen_screen__Q0lyG\",\"screenFrame\":\"Screen_screenFrame__BXMp8\",\"rowLine\":\"Screen_rowLine__1HFM3\"};","import { memo } from \"react\";\nimport styles from './Square.module.css';\n\nconst Square = ({ isFilled }) => {\n    return (\n        <div className={`${styles.squareWrapper}`}>\n            <div className={`${styles.square} ${isFilled && styles.filledSquare}`} >\n                <div className={`${styles.innerSquare} ${isFilled && styles.filledInnerSquare}`} />\n            </div>\n        </div>\n    )\n};\n\nexport default memo(Square);\n","import { memo } from \"react\";\nimport Square from \"../Square\";\nimport styles from './Screen.module.css';\n\nconst Screen = ({ screen, fieldSize }) => {\n    return (\n        <div className={styles.screen}>\n            <div className={styles.screenFrame}>\n                {[...Array(fieldSize.y)].map((row, rowIdY) => (\n                    <div key={rowIdY} className={styles.rowLine}>\n                        {\n                            [...Array(fieldSize.x)].map((rowItem, rowIdX) => {\n                                const currentSquareIndex = fieldSize.x * rowIdY + rowIdX;\n                                return (\n                                    <Square key={`${rowIdX}_${rowIdY}`} isFilled={screen[currentSquareIndex].isFilled} />\n                                )\n                            })\n                        }\n                    </div>\n                ))\n                }\n            </div>\n        </div>\n    );\n}\n\nexport default memo(Screen);\n","import React, { useEffect } from 'react';\n\nconst GameControl = ({ keyPressHandler }) => {\n    const handler = event => keyPressHandler(event);\n\n    useEffect(() => {\n        document.addEventListener('keydown', handler);\n\n        return () => {\n            document.removeEventListener('keydown', handler);\n        };\n    }, []);\n\n    return <div/>;\n};\n\nexport default GameControl;\n","import {\n    useRef,\n    useReducer,\n    useEffect,\n    useMemo\n} from \"react\";\n\nconst useLogic = () => {\n    let intervalRef = useRef();\n\n    const fieldSize = useMemo(() => ({ x: 20, y: 20}), []);\n\n    const initSnakeBody = [...Array(4)]\n        .map((_, index) => ({\n            x: index + 4,\n            y: 5,\n            isFilled: !!index,\n            isTarget: false\n        }));\n\n    const generateInitField = useMemo(() => {\n        return [...Array(fieldSize.y)].flatMap((_, j) => [...Array(fieldSize.x)].map((_, i) =>\n            ({\n                x: i,\n                y: j,\n                isFilled: false,\n                isTarget: false\n            })))\n    }, [fieldSize]);\n\n    const initFieldChanges = useMemo(() => {\n        return generateInitField.reduce((acc, el) => {\n            if (el.x === 0 || el.x === fieldSize.x - 1 || el.y === 0 || el.y === fieldSize.y - 1) {\n                return acc.concat({ ...el, isFilled: true });\n            }\n\n            return acc;\n        }, [])\n    }, [fieldSize]);\n\n\n    const prepareNewScreenState = (screenState, changes) => {\n        let newScreenState = [...screenState];\n        changes.forEach(change => newScreenState[fieldSize.x * change.y + change.x] = change);\n\n        return newScreenState;\n    };\n\n    const initSnakeState = {\n        restartFlag: false,\n        isGameRunning: false,\n        isMatchIsOn: false,\n        isGameOver: false,\n        body: [...initSnakeBody],\n        screen: prepareNewScreenState(generateInitField, initFieldChanges),\n        currentDirection: { dir: 'forward', ax: 'horizontal' },\n        nextDirection: { dir: 'forward', ax: 'horizontal' }\n    };\n\n    const getSnakeParams = state => {\n        let copiedState = {...state};\n        const filteredBodyState = copiedState.body\n        const cutTail = !filteredBodyState[0]['isFilled'] ? filteredBodyState.shift() : {};\n        filteredBodyState[0]['isFilled'] = true;\n        const direction = copiedState.currentDirection.ax === copiedState.nextDirection.ax ? 'currentDirection' : 'nextDirection';\n        const cd = copiedState[direction].ax === 'horizontal' ? 'x' : 'y';\n        const currenHead = {...filteredBodyState[filteredBodyState.length - 1]};\n        const getNextBodyPixel = prev => ({\n            ...prev,\n            [cd]: state[direction].dir === 'forward' ? prev[cd] + 1 : prev[cd] - 1,\n            isTarget: false\n        })\n        const newHead = getNextBodyPixel(currenHead);\n\n        return {\n            filteredBodyState,\n            direction,\n            currenHead,\n            cutTail,\n            getNextBodyPixel,\n            newHead\n        }\n    };\n\n    const getNextTarget = (screen, occupied) => {\n        let copiedScreen = [...screen];\n        occupied.forEach(change => {\n            copiedScreen.splice([fieldSize.x * change.y + change.x], 1);\n        });\n\n        const unfilledScreenPixels = copiedScreen.filter(pix => !pix.isFilled)\n\n        return {\n            ...unfilledScreenPixels[Math.floor(Math.random() * unfilledScreenPixels.length)],\n            isFilled: true,\n            isTarget: true,\n        };\n    };\n\n    const setTargetPixel = state => {\n        const { newHead } = getSnakeParams(state);\n        const newTarget = getNextTarget(\n            state.screen, [...initSnakeBody, newHead]\n        );\n        const newScreenState = prepareNewScreenState(state.screen, [newTarget]);\n\n        return { screen: newScreenState };\n    };\n\n    const snakeStateReducer = (state, action) => {\n        if (action.type === 'prepareAndExecNewTurn') {\n            const {\n                filteredBodyState,\n                direction,\n                cutTail,\n                newHead\n            } = getSnakeParams(state);\n\n            const nextHeadPlace = {...state.screen[fieldSize.x * newHead.y + newHead.x]};\n\n            if (nextHeadPlace.isFilled && !nextHeadPlace.isTarget) {\n                return {\n                    ...state,\n                    isGameRunning: false,\n                    isMatchIsOn: false,\n                    isGameOver: true,\n                    currentDirection: { dir: 'forward', ax: 'horizontal' },\n                    nextDirection: { dir: 'forward', ax: 'horizontal' }\n                }\n            }\n\n            let newSnakeBodyState = [...filteredBodyState];\n\n            if (nextHeadPlace.isTarget) {\n                newSnakeBodyState.splice(1, 0, { ...newSnakeBodyState[0], isFilled: false });\n            }\n\n            newSnakeBodyState = newSnakeBodyState\n                .map((pix, idx) => idx === 0 ? { ...pix, isFilled: false} : pix)\n                .concat(newHead);\n\n            let newScreenState = prepareNewScreenState(state.screen, newSnakeBodyState);\n\n            if (nextHeadPlace.isTarget) {\n                newScreenState = prepareNewScreenState(newScreenState, [getNextTarget(newScreenState, [cutTail])]);\n            }\n\n            const newDirection = state[direction];\n\n            return {\n                ...state,\n                screen: newScreenState,\n                body: newSnakeBodyState,\n                currentDirection: newDirection\n            };\n        }\n\n        if (action.type ==='keyPressHandler') {\n            action.payload.preventDefault();\n            const direction = {\n                ArrowLeft: { dir: 'backward', ax: 'horizontal' },\n                ArrowRight: { dir: 'forward', ax: 'horizontal' },\n                ArrowUp: { dir: 'backward', ax: 'vertical' },\n                ArrowDown: { dir: 'forward', ax: 'vertical' },\n                KeyA: { dir: 'backward', ax: 'horizontal' },\n                KeyD: { dir: 'forward', ax: 'horizontal' },\n                KeyW: { dir: 'backward', ax: 'vertical' },\n                KeyS: { dir: 'forward', ax: 'vertical' }\n            }[action.payload.code];\n\n            if (!(state.nextDirection.dir ===  direction?.dir && state.nextDirection.ax ===  direction?.ax) &&\n                direction &&\n                state.isGameRunning) {\n                return { ...state, nextDirection: direction }\n            }\n\n            return state;\n        }\n\n        if (action.type === 'startOrPause') {\n            const {\n                isGameRunning,\n                isMatchIsOn,\n                isGameOver,\n                body,\n                screen\n            } = state;\n\n            const stateWithoutTarget = {\n                ...state,\n                isGameOver: false,\n                isMatchIsOn: true,\n                isGameRunning: !isGameRunning,\n                screen: !isMatchIsOn ? prepareNewScreenState(generateInitField, [...initFieldChanges, ...initSnakeBody]) : screen,\n                body: isGameOver ? [...initSnakeState.body] : body,\n            }\n\n            return {\n                ...stateWithoutTarget,\n                ...(!isMatchIsOn && setTargetPixel(stateWithoutTarget))\n            }\n        }\n\n        if (action.type === 'resetHandler') {\n            const { restartFlag, isGameRunning, isMatchIsOn, isGameOver } = state;\n            const setParams = {\n                isGameRunning: !isMatchIsOn && isGameOver ? true : isGameRunning,\n                isMatchIsOn: !restartFlag ? isGameOver : true\n            };\n\n            const fillScreen = restartFlag || isGameOver ? {\n                screen: prepareNewScreenState(generateInitField, [...initFieldChanges, ...initSnakeBody])\n            } : {};\n\n            const stateWithoutTarget = {\n                ...state,\n                ...initSnakeState,\n                ...setParams,\n                ...fillScreen,\n                restartFlag: restartFlag\n            };\n\n            return {\n                ...stateWithoutTarget,\n                ...(((restartFlag && isMatchIsOn) || isGameOver) && setTargetPixel(stateWithoutTarget))\n            };\n        }\n\n        if (action.type === 'stopInterval') {\n            return {\n                ...state,\n                restartFlag: state.isGameRunning || state.isGameOver,\n                isGameRunning: false\n            }\n        }\n\n        if (action.type === 'startInterval') {\n            return {\n                ...state,\n                restartFlag: false,\n                isGameRunning: state.restartFlag\n            }\n        }\n\n        return new Error();\n    };\n\n    const [snakeState, dispatchSnakeState] = useReducer(snakeStateReducer, initSnakeState);\n\n    const resetGame = async() => {\n        await dispatchSnakeState({\n            type: 'stopInterval'\n        });\n\n        await dispatchSnakeState({\n            type: 'resetHandler'\n        });\n\n        await dispatchSnakeState({\n            type: 'startInterval'\n        });\n    };\n\n    const keyPressHandler = event => {\n        event.preventDefault();\n\n        dispatchSnakeState({\n            type: 'keyPressHandler',\n            payload: event\n        });\n\n        if (event.code === 'Space') {\n            startOrPauseGame();\n        }\n\n        if (event.code === 'Backspace') {\n            resetGame();\n        }\n    };\n\n    const startOrPauseGame = async () => {\n        await dispatchSnakeState({\n            type: 'startOrPause'\n        })\n    };\n\n    useEffect(() => {\n        if(snakeState.isGameRunning) {\n            intervalRef.current = setInterval(() => dispatchSnakeState({ type: 'prepareAndExecNewTurn' }), 200);\n        }\n\n        if (!snakeState.isGameRunning) {\n            clearInterval(intervalRef.current);\n            intervalRef.current = null;\n        }\n    }, [snakeState.isGameRunning]);\n\n    return {\n        fieldSize,\n        snakeState,\n        startOrPauseGame,\n        resetGame,\n        keyPressHandler\n    };\n}\n\nexport default useLogic;\n","import styles from './App.module.css';\nimport Screen from \"./Screen\";\nimport GameControl from \"./GameControl\";\nimport useLogic from \"./Hooks/useLogic\";\n\nconst App = () => {\n    const {\n        fieldSize,\n        snakeState,\n        startOrPauseGame,\n        resetGame,\n        keyPressHandler\n    } = useLogic();\n\n    return (\n        <div className={styles.App}>\n            <Screen screen={snakeState.screen} fieldSize={fieldSize} />\n            <div className={styles.buttonPanel}>\n                <button className={styles.button} onClick={startOrPauseGame}>{snakeState.isGameRunning || snakeState.restartFlag ? 'Pause' : 'Start'}</button>\n                <button className={styles.button} onClick={resetGame}>Reset</button>\n            </div>\n            <GameControl keyPressHandler={keyPressHandler} />\n        </div>\n    );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport './styles.css'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"squareWrapper\":\"Square_squareWrapper__1-5jq\",\"square\":\"Square_square__5MeBN\",\"filledSquare\":\"Square_filledSquare__3nVrd\",\"innerSquare\":\"Square_innerSquare__1V41H\",\"filledInnerSquare\":\"Square_filledInnerSquare__3sDlX\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"App\":\"App_App__16ZpL\",\"buttonPanel\":\"App_buttonPanel__24-jo\",\"button\":\"App_button__13pio\"};"],"sourceRoot":""}